/* 猴子分桃
老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富——一大堆桃子。老猴子决定把这些桃子分给小猴子。
第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。

假设刚开始有x个桃子，借给猴子4个就可以刚好分完；
当第一只猴子来分完桃子后，还剩下(x+4)*(4/5)个桃子，而他所得到的桃子其实是(x+4)*(1/5)-1=（x-1)*(1/5)个，减去的一个就是老猴子的.
第二只猴子来分完后还剩下(x+4)*(4/5)^2个桃子；
第三只猴子来分完后还剩下(x+4)*(4/5)^3个桃子；
以此类推下去...第n只猴子拿走桃子后剩余(x+4)*(4/5)^n个桃子。

为了满足题目要求，也就是要保证最后剩余的桃子数最少且为整数，那么当 X+4 = 5^n 时，刚好满足要求，此时可得出：
开始时的总桃子数：X = 5^n - 4
老猴子最后能得到的桃子数：n + (X+4)*(4/5)^n - 4 = n + 4^n - 4 */

#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
	int n;
	while (cin >> n)
    {
        if(n == 0)
            break;
        long a = pow(5, n) - 4;
		    long b = pow(4, n) + n - 4;
		    cout << a <<" "<< b << endl;
	  }
	return 0;
}
